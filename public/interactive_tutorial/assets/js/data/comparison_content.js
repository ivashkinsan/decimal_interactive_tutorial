
export const comparisonContent = {
    's21_is_less': {
        title: 's21_is_less',
        simple: 'Представьте числовую прямую. Эта функция просто проверяет, находится ли первое число левее второго. Например, 5 "меньше" 10, а -100 "меньше" -5.',
        why: 'Это одна из фундаментальных операций. Без нее невозможна сортировка данных, проверка диапазонов (например, "цена ниже максимальной?") и построение любой сложной логики, основанной на упорядочивании.',
        description: 'Функция `s21_is_less` возвращает `1` (истина), если `value_1` строго меньше `value_2`, и `0` (ложь) в противном случае.',
        prototype: 'int s21_is_less(s21_decimal value_1, s21_decimal value_2);',
        details: 'Алгоритм сначала проверяет знаки. Если `value_1` отрицательное, а `value_2` положительное, результат очевиден. Если знаки одинаковые, функция приводит оба числа к общему `scale` (нормализует их) и затем побитово сравнивает их 96-битные мантиссы, чтобы определить, какая из них меньше.'
    },
    's21_is_less_or_equal': {
        title: 's21_is_less_or_equal',
        simple: 'Похоже на `s21_is_less`, но также включает случай, когда числа равны. Проверяет, находится ли первое число левее второго или в той же точке.',
        why: 'Используется для проверок нестрогих неравенств, например, "количество товара на складе меньше или равно нулю?" или "прошло времени не более 5 минут".',
        description: 'Возвращает `1` (истина), если `value_1` меньше или равно `value_2`.',
        prototype: 'int s21_is_less_or_equal(s21_decimal value_1, s21_decimal value_2);',
        details: 'Часто реализуется как `s21_is_less(value_1, value_2) || s21_is_equal(value_1, value_2)`. Это эффективнее, чем дублировать логику.'
    },
    's21_is_greater': {
        title: 's21_is_greater',
        simple: 'Противоположность `s21_is_less`. Проверяет, находится ли первое число правее второго на числовой прямой.',
        why: 'Так же, как и `s21_is_less`, это базовая операция для сортировок и логических проверок (например, "баланс больше необходимого минимума?").',
        description: 'Возвращает `1` (истина), если `value_1` строго больше `value_2`.',
        prototype: 'int s21_is_greater(s21_decimal value_1, s21_decimal value_2);',
        details: 'Алгоритм аналогичен `s21_is_less`, но с инвертированной логикой сравнения мантисс после нормализации.'
    },
    's21_is_greater_or_equal': {
        title: 's21_is_greater_or_equal',
        simple: 'Проверяет, находится ли первое число правее второго или в той же точке.',
        why: 'Нужно для нестрогих проверок, например, "возраст пользователя больше или равен 18?" или "сумма на счете не меньше нуля".',
        description: 'Возвращает `1` (истина), если `value_1` больше или равно `value_2`.',
        prototype: 'int s21_is_greater_or_equal(s21_decimal value_1, s21_decimal value_2);',
        details: 'Обычно реализуется через `s21_is_greater(value_1, value_2) || s21_is_equal(value_1, value_2)`.'
    },
    's21_is_equal': {
        title: 's21_is_equal',
        simple: 'Проверяет, что два числа — это одно и то же значение, как две гири с одинаковым весом. `1.23` и `1.230` считаются равными.',
        why: 'Ключевая операция для поиска точных значений, проверки равенства (например, "введенная сумма совпадает с суммой счета?") и для работы других функций, как `s21_is_less_or_equal`.',
        description: 'Возвращает `1` (истина), если `value_1` и `value_2` численно равны.',
        prototype: 'int s21_is_equal(s21_decimal value_1, s21_decimal value_2);',
        details: 'Даже если у чисел разный `scale` (например, 1.5 и 1.50), они равны. Поэтому функция сначала нормализует их к общему `scale`, а затем побитово сравнивает все 96 бит мантиссы. Знаки также должны совпадать (за исключением +0 и -0, которые равны).'
    },
    's21_is_not_equal': {
        title: 's21_is_not_equal',
        simple: 'Проверяет, что числа не равны. Это просто инверсия (противоположность) `s21_is_equal`.',
        why: 'Удобно для проверок, когда нужно убедиться, что значение изменилось или не равно определенному флагу/константе.',
        description: 'Возвращает `1` (истина), если `value_1` и `value_2` не равны.',
        prototype: 'int s21_is_not_equal(s21_decimal value_1, s21_decimal value_2);',
        details: 'Самый простой способ реализации — `!s21_is_equal(value_1, value_2)`. Это избавляет от необходимости писать отдельный сложный алгоритм.'
    }
};
