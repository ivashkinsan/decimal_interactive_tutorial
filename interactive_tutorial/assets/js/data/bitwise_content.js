
export const bitwiseContent = {
    'concept_bitwise_ops': {
        title: 'Концепция: Побитовые операции',
        interactive: 'bitwise_operations',
        simple: 'Представьте, что у вас есть два списка покупок (да/нет для каждого товара). Операция `AND` оставит в итоговом списке только те товары, которые есть в ОБОИХ списках. `OR` — те, что есть ХОТЯ БЫ В ОДНОМ. `XOR` — те, что есть только в одном из списков, но не в обоих. `NOT` — просто инвертирует список (что было "да", станет "нет").',
        why: 'Побитовые операции — это фундамент. Они позволяют манипулировать данными на самом низком уровне. В s21_decimal они используются для установки и чтения знака, масштаба, а также для реализации сложных алгоритмов умножения и деления, которые работают быстрее стандартных математических операций.',
        description: 'Компьютер хранит все данные в виде нулей и единиц (битов). Побитовые операции работают непосредственно с этими битами. `AND (&)` возвращает 1, только если оба бита равны 1. `OR (|)` возвращает 1, если хотя бы один из битов равен 1. `XOR (^)` возвращает 1, если биты разные. `NOT (~)` инвертирует все биты (0 становится 1, и наоборот).'
    },
    'concept_bit_shifting': {
        title: 'Концепция: Битовые сдвиги',
        interactive: 'bit_shifting',
        simple: 'Представьте число в двоичном виде, например, `110` (это 6). Сдвиг влево на 1 (`<< 1`) — это как дописать ноль в конце, получится `1100` (12). Сдвиг вправо (`>> 1`) — как убрать последнюю цифру, получится `11` (3). Это супер-быстрое умножение и деление на 2.',
        why: 'Это самый эффективный способ умножать и делить целые числа на степени двойки (2, 4, 8, 16...). Компиляторы часто сами заменяют обычное умножение/деление на сдвиги. В s21_decimal это используется в алгоритмах умножения, деления и нормализации для быстрой работы с мантиссой.',
        description: 'Оператор сдвига влево `<< n` сдвигает все биты числа влево на `n` позиций, заполняя освободившиеся справа места нулями. Это эквивалентно умножению на 2^n. Оператор сдвига вправо `>> n` сдвигает биты вправо на `n` позиций. Для беззнаковых чисел освободившиеся слева места заполняются нулями (логический сдвиг), что эквивалентно целочисленному делению на 2^n.'
    },
    'concept_scale_sign': {
        title: 'Концепция: Кодирование Scale и Sign',
        interactive: 'scale_sign_encoder',
        simple: 'Представьте, что у вас есть паспорт числа. В нем есть поле "знак" (плюс или минус) и поле "сколько знаков после запятой". В s21_decimal для этого паспорта выделен отдельный `int` (`bits[3]`), и информация записывается в строго определенные ячейки-биты.',
        why: 'Нужно где-то хранить мета-информацию о числе. Выделение для этого отдельного целого числа (`bits[3]`) позволяет нам не смешивать управляющую информацию с самим значением (мантиссой). Это делает код чище и позволяет быстро получать доступ к знаку и масштабу с помощью битовых масок и сдвигов.',
        description: 'В `bits[3]` используются только старшие 16 бит. Биты с 16 по 23 (всего 8 бит) отвечают за `scale`. Число от 0 до 28 записывается в эти биты. 31-й бит отвечает за знак: 0 — положительное число, 1 — отрицательное. Остальные биты в `bits[3]` не используются и должны быть равны нулю. Для чтения и записи этих значений используются побитовые маски и сдвиги.'
    },
    'concept_precision': {
        title: 'Концепция: Сравнение точности',
        interactive: 'precision_comparison',
        simple: 'Попросите калькулятор на `float` сложить 0.1 и 0.2. Он может выдать `0.30000000000000004`. `s21_decimal` для той же операции выдаст ровно `0.3`. Он работает как человек, который считает на бумаге, и не теряет "копейки" из-за особенностей двоичного представления.',
        why: 'Тип `float` не может точно представить большинство десятичных дробей (0.1, 0.2, 0.7). Для научных расчетов это приемлемо, но в финансах, где важен каждый цент, такие ошибки недопустимы. `s21_decimal` был создан именно для решения этой проблемы — гарантировать абсолютную точность для десятичных чисел.',
        description: 'Проблема `float` в том, что он хранит числа в формате `мантисса * 2^степень`. Дробь 1/10 (0.1) в двоичной системе является бесконечной (`0.0001100110011...`). `float` обрезает эту дробь, внося ошибку. `s21_decimal` хранит `0.1` как целое число `1` и `scale` равный `1`. Таким образом, в памяти хранится точное значение без какого-либо округления, что и обеспечивает точность вычислений.'
    },
};
