
export const arithmeticContent = {
    'arithmetic_operations': {
        id: 'arithmetic_operations',
        title: 'Арифметические операции',
        // This will be a landing page or overview, not directly interactive
        simple: 'Это базовые математические действия: сложение, вычитание, умножение и деление. Здесь вы можете изучить, как эти операции выполняются с `s21_decimal` и увидеть их пошаговую логику.',
        why: 'Без точной и надежной арифметики невозможно проводить никакие расчеты, особенно в финансовой сфере. Эти функции — ядро всей библиотеки.',
        description: 'Каждая арифметическая операция работает с 96-битными мантиссами и управляющими битами (`scale` и знак) в `bits[3]`. Перед сложением и вычитанием числа приводятся к общему `scale` (нормализуются). При умножении их `scale` складываются, а при делении — вычитаются.'
    },
    's21_add': {
        id: 's21_add',
        title: 'Сложение (s21_add)',
        interactive: 'addition_simulator',
        description: `
            <h3>Функция s21_add</h3>
            <p>Функция <code>s21_add</code> выполняет сложение двух десятичных чисел.</p>
            <h4>Пример использования:</h4>
            <pre><code class="c">
#include "s21_decimal.h"
#include <stdio.h>

int main() {
    s21_decimal val1, val2, result;
    s21_from_float_to_decimal(10.5f, &val1);
    s21_from_float_to_decimal(2.3f, &val2);

    int error = s21_add(val1, val2, &result);

    if (error == 0) {
        float float_result;
        s21_from_decimal_to_float(result, &float_result);
        printf("Результат сложения: %f\n", float_result); // Вывод: 12.800000
    }

    return 0;
}
            </code></pre>
            <h4>Логика реализации: Мышление программиста</h4>
            <ol>
                <li><b>Первая мысль: обработать знаки.</b> Сложение не всегда является простым сложением. Если знаки разные (например, 5 + (-3)), это на самом деле вычитание. Проще всего сразу проверить этот случай. Если знаки разные, я инвертирую знак второго числа и вызову уже написанную функцию <code>s21_sub</code>. Это хороший пример переиспользования кода.</li>
                <li><b>Проблема разных масштабов.</b> Если знаки одинаковые, нужно складывать мантиссы. Но что если у нас 1.23 (мантисса 123, scale 2) и 4.5 (мантисса 45, scale 1)? Я не могу просто сложить 123 и 45. Мне нужно привести их к общему знаменателю.</li>
                <li><b>Нужна нормализация.</b> Я напишу вспомогательную функцию <code>normalize</code>. Она найдет число с меньшим масштабом и будет умножать его мантиссу на 10, пока масштабы не сравняются. В нашем примере 4.5 (scale 1) превратится в 4.50 (мантисса 450, scale 2). Теперь я могу сложить мантиссы 123 и 450.</li>
                <li><b>Опасность переполнения при нормализации.</b> А что если при умножении мантиссы на 10 она выйдет за пределы 96 бит? Моя функция <code>normalize</code> должна это проверять. Если переполнение происходит, я не могу выполнить операцию и должен вернуть ошибку.</li>
                <li><b>Сложение мантисс.</b> Теперь, когда мантиссы выровнены, я могу их сложить. Это операция над 96-битными числами. Я напишу для этого отдельную вспомогательную функцию <code>add_mantissas</code>. Она тоже должна проверять, не вышел ли результат за пределы 96 бит.</li>
                <li><b>Переполнение итоговой мантиссы.</b> Если <code>add_mantissas</code> сообщает о переполнении, возможно, я смогу спасти ситуацию. Я могу попробовать уменьшить масштаб результата (разделить мантиссу на 10) и округлить ее. Если и это не помогает, я должен вернуть ошибку переполнения.</li>
                <li><b>Сборка результата.</b> Если все прошло успешно, я создаю итоговый <code>s21_decimal</code>: знак будет общим для обоих чисел, масштаб — тот, к которому мы нормализовали, а мантисса — результат сложения.</li>
            </ol>
        `,
    },
    's21_sub': {
        id: 's21_sub',
        title: 'Вычитание (s21_sub)',
        interactive: 'subtraction_simulator',
        description: `
            <h3>Функция s21_sub</h3>
            <p>Функция <code>s21_sub</code> выполняет вычитание одного десятичного числа из другого.</p>
            <h4>Логика реализации: Мышление программиста</h4>
            <ol>
                <li><b>Сводим к сложению.</b> Вычитание — это сложение с отрицательным числом. <code>A - B</code> это то же самое, что <code>A + (-B)</code>. Я могу просто инвертировать знак у <code>value_2</code> и вызвать уже готовую функцию <code>s21_add</code>. Это элегантное решение, которое избавляет от дублирования кода.</li>
                <li><b>Альтернативный путь: прямое вычитание.</b> Если я все же хочу реализовать вычитание напрямую, логика будет похожа на сложение. Сначала нормализация. Затем, если знаки одинаковые, я вычитаю мантиссы (<code>sub_mantissas</code>). Если меньшая мантисса вычитается из большей, все просто. Если наоборот, мне нужно поменять их местами, вычесть, а затем инвертировать знак результата.</li>
                <li><b>Разные знаки.</b> Если знаки разные (например, <code>5 - (-3)</code>), это превращается в сложение (<code>5 + 3</code>). Я просто меняю знак второго числа и вызываю <code>s21_add</code>.</li>
            </ol>
        `,
    },
    's21_mul': {
        id: 's21_mul',
        title: 'Умножение (s21_mul)',
        interactive: 'multiplication_simulator',
        description: `
            <h3>Функция s21_mul</h3>
            <p>Функция <code>s21_mul</code> выполняет умножение двух десятичных чисел.</p>
            <h4>Пример использования:</h4>
            <pre><code class="c">
s21_decimal val1, val2, result;
s21_from_float_to_decimal(10.5f, &val1);
s21_from_float_to_decimal(2.0f, &val2);

s21_mul(val1, val2, &result); // Результат будет 21.0
            </code></pre>
            <h4>Логика реализации: Мышление программиста</h4>
            <ol>
                <li><b>Знак и масштаб.</b> С ними все просто. Знак результата определяется по школьным правилам (минус на минус дает плюс). Масштаб результата — это просто сумма масштабов двух чисел.</li>
                <li><b>Умножение мантисс.</b> Это самая сложная часть. Умножение двух 96-битных чисел может дать результат размером до 192 бит. Мне понадобится реализовать алгоритм "длинного умножения" (умножение в столбик), который будет работать с 32-битными частями мантисс.</li>
                <li><b>Проверка на переполнение.</b> После умножения мантисс я получу очень большое число. Если оно не помещается в 96 бит, это переполнение. Я должен проверить это. Если результат переполнен, но масштаб результата больше 0, я могу попытаться уменьшить его (разделить мантиссу на 10 и уменьшить масштаб на 1), пока мантисса не влезет в 96 бит. При каждом делении нужно применять банковское округление.</li>
                <li><b>Финальная сборка.</b> Если все успешно, я записываю итоговую мантиссу, знак и масштаб в результирующий <code>s21_decimal</code>.</li>
            </ol>
        `,
    },
    's21_div': {
        id: 's21_div',
        title: 'Деление (s21_div)',
        interactive: 'division_simulator',
        description: `
            <h3>Функция s21_div</h3>
            <p>Функция <code>s21_div</code> выполняет деление одного десятичного числа на другое.</p>
            <h4>Логика реализации: Мышление программиста</h4>
            <ol>
                <li><b>Проверка на ноль.</b> Первое, что нужно сделать — проверить, не равен ли делитель нулю. Если да, это ошибка, и я должен немедленно вернуть код <code>DIVISION_BY_ZERO</code>.</li>
                <li><b>Знак и масштаб.</b> Знак определяется так же, как при умножении. С масштабом сложнее. Для начала я могу увеличить мантиссу делимого, умножая ее на 10, чтобы сохранить точность после запятой. Масштаб результата будет равен разнице масштабов (с учетом этих умножений).</li>
                <li><b>Деление мантисс.</b> Это, как и умножение, сложный процесс. Мне нужно реализовать алгоритм "длинного деления" для 96-битных чисел. Он будет итеративно вычитать сдвинутую мантиссу делителя из делимого, формируя биты результата.</li>
                <li><b>Точность.</b> В процессе деления я буду получать все больше и больше знаков после запятой. Мне нужно остановиться, когда я достигну требуемой точности (обычно 28 знаков), или когда остаток станет равен нулю.</li>
                <li><b>Округление.</b> После завершения деления, возможно, понадобится округлить результат до стандартных 28 знаков после запятой.</li>
            </ol>
        `,
    },
    's21-decimal-c-plan': {
        id: 's21-decimal-c-plan',
        title: 'План реализации на C',
        description: 'Подробный план по написанию функций s21_decimal на языке C.',
        template: `
      <h3>Общий план реализации функций s21_decimal на C</h3>
      <p>Для успешной реализации библиотеки s21_decimal на языке C необходимо следовать четкому плану, учитывая особенности представления десятичных чисел и требования к точности.</p>

      <h4>1. Структура s21_decimal</h4>
      <p>Определите структуру <code>s21_decimal</code>, которая будет хранить 128-битное десятичное число. Обычно это достигается использованием массива из четырех 32-битных целых чисел (<code>int bits[4]</code>).</p>
      <ul>
        <li><code>bits[0]</code>, <code>bits[1]</code>, <code>bits[2]</code>: Хранят 96-битную мантиссу числа. <code>bits[0]</code> - младшие биты, <code>bits[2]</code> - старшие.</li>
        <li><code>bits[3]</code>: Хранит информацию о знаке и степени (масштабе).
          <ul>
            <li>Биты 0-15: Не используются (зарезервированы).</li>
            <li>Биты 16-23: Хранят степень (scale) от 0 до 28.</li>
            <li>Биты 24-30: Не используются (зарезервированы).</li>
            <li>Бит 31: Хранит знак числа (0 для положительного, 1 для отрицательного).</li>
          </ul>
        </li>
      </ul>
      <pre><code class="c">
typedef struct s21_decimal {
    int bits[4];
} s21_decimal;
      </code></pre>

      <h4>2. Вспомогательные функции</h4>
      <p>Реализуйте набор вспомогательных функций для работы с битами, знаком и степенью:</p>
      <ul>
        <li><code>s21_get_sign(s21_decimal dec)</code>: Возвращает знак числа.</li>
        <li><code>s21_set_sign(s21_decimal *dec, int sign)</code>: Устанавливает знак числа.</li>
        <li><code>s21_get_scale(s21_decimal dec)</code>: Возвращает степень числа.</li>
        <li><code>s21_set_scale(s21_decimal *dec, int scale)</code>: Устанавливает степень числа.</li>
        <li><code>s21_is_zero(s21_decimal dec)</code>: Проверяет, равно ли число нулю.</li>
        <li><code>s21_shift_left(s21_decimal *dec, int shift)</code>: Сдвигает мантиссу влево.</li>
        <li><code>s21_shift_right(s21_decimal *dec, int shift)</code>: Сдвигает мантиссу вправо.</li>
        <li><code>s21_normalize(s21_decimal *value_1, s21_decimal *value_2)</code>: Приводит два числа к общей степени, увеличивая степень меньшего числа и умножая его мантиссу.</li>
        <li><code>s21_add_mantissa(s21_decimal value_1, s21_decimal value_2, s21_decimal *result)</code>: Складывает только мантиссы двух чисел (без учета знака и степени). Возвращает код ошибки переполнения.</li>
        <li><code>s21_sub_mantissa(s21_decimal value_1, s21_decimal value_2, s21_decimal *result)</code>: Вычитает только мантиссы двух чисел.</li>
      </ul>

      <h4>3. Арифметические операции</h4>
      <p>Основные арифметические функции должны учитывать знаки, приводить числа к общей степени и обрабатывать переполнение.</p>
      <ul>
        <li><strong><code>int s21_add(s21_decimal value_1, s21_decimal value_2, s21_decimal *result)</code></strong>
          <ul>
            <li><b>Общая логика сложения:</b>
              <ol>
                <li><b>Обработка знаков:</b>
                  <ul>
                    <li>Если знаки <code>value_1</code> и <code>value_2</code> разные, операция превращается в вычитание. Например, <code>A + (-B)</code> становится <code>A - B</code>, а <code>(-A) + B</code> становится <code>B - A</code>.</li>
                    <li>Если знаки одинаковые, сохраните этот знак для результата.</li>
                  </ul>
                </li>
                <li><b>Нормализация:</b>
                  <ul>
                    <li>Приведите <code>value_1</code> и <code>value_2</code> к общей степени (<code>scale</code>). Это делается путем увеличения <code>scale</code> меньшего числа и соответствующего умножения его мантиссы на 10. Используйте вспомогательную функцию <code>s21_normalize</code>.</li>
                    <li>Если при нормализации происходит переполнение мантиссы, это может привести к ошибке.</li>
                  </ul>
                </li>
                <li><b>Сложение мантисс:</b>
                  <ul>
                    <li>Используйте вспомогательную функцию <code>s21_add_mantissa</code> для сложения 96-битных мантисс. Эта функция должна возвращать код ошибки, если происходит переполнение мантиссы.</li>
                  </ul>
                </li>
                <li><b>Обработка переполнения:</b>
                  <ul>
                    <li>Если <code>s21_add_mantissa</code> возвращает ошибку переполнения, или если после сложения мантисса слишком велика для представления, установите соответствующий код ошибки (например, <code>OVERFLOW</code> для положительного переполнения или <code>NEGATIVE_OVERFLOW</code> для отрицательного).</li>
                    <li>Возможно, потребуется уменьшить <code>scale</code> результата и округлить мантиссу, чтобы избежать переполнения, если это допустимо по спецификации.</li>
                  </ul>
                </li>
                <li><b>Установка знака и степени результата:</b>
                  <ul>
                    <li>Установите знак результата, определенный на первом шаге.</li>
                    <li>Установите общую степень, полученную после нормализации.</li>
                  </ul>
                </li>
                <li><b>Обработка нуля:</b> Если результат равен нулю, убедитесь, что его знак положительный, а степень равна нулю.</li>
              </ol>
            </li>
            <li><b>Псевдокод для <code>s21_add</code>:</b>
              <pre><code class="c">
int s21_add(s21_decimal value_1, s21_decimal value_2, s21_decimal *result) {
    // Инициализация result нулями
    обнулить(result);

    // Получение знаков и степеней
    sign1 = s21_get_sign(value_1);
    sign2 = s21_get_sign(value_2);
    scale1 = s21_get_scale(value_1);
    scale2 = s21_get_scale(value_2);

    // Обработка случаев с нулем
    если (s21_is_zero(value_1)) вернуть s21_from_decimal_to_decimal(value_2, result);
    если (s21_is_zero(value_2)) вернуть s21_from_decimal_to_decimal(value_1, result);

    // Если знаки разные, преобразовать в вычитание
    если (sign1 != sign2) {
        // Пример: 5 + (-3) = 5 - 3
        // Пример: (-5) + 3 = 3 - 5
        // Установить знак value_2 на противоположный и вызвать s21_sub
        s21_set_sign(&value_2, sign1);
        вернуть s21_sub(value_1, value_2, result);
    }

    // Нормализация степеней
    ошибка_нормализации = s21_normalize(&value_1, &value_2);
    если (ошибка_нормализации != OK) вернуть ошибка_нормализации; // Обработка переполнения при нормализации

    // Сложение мантисс
    ошибка_сложения = s21_add_mantissa(value_1, value_2, result);

    // Установка знака и степени результата
    s21_set_sign(result, sign1);
    s21_set_scale(result, s21_get_scale(value_1)); // Общая степень после нормализации

    // Обработка переполнения после сложения мантисс
    если (ошибка_сложения != OK) {
        // Попытка уменьшить степень и округлить, если возможно
        // ... (логика округления и уменьшения степени)
        вернуть OVERFLOW; // Или NEGATIVE_OVERFLOW в зависимости от знака
    }

    вернуть OK;
}
              </code></pre>
            </li>
          </ul>
        </li>
        <li><strong><code>int s21_sub(s21_decimal value_1, s21_decimal value_2, s21_decimal *result)</code></strong>
          <ul>
            <li>Аналогично сложению, но с учетом правил вычитания для разных знаков.</li>
            <li>Используйте <code>s21_sub_mantissa</code>.</li>
          </ul>
        </li>
        <li><strong><code>int s21_mul(s21_decimal value_1, s21_decimal value_2, s21_decimal *result)</code></strong>
          <ul>
            <li>Определите знак результата.</li>
            <li>Умножьте мантиссы. Это может потребовать итеративного сложения или более сложного алгоритма для 96-битных чисел.</li>
            <li>Сложите степени.</li>
            <li>Проверьте на переполнение мантиссы и степени.</li>
          </ul>
        </li>
        <li><strong><code>int s21_div(s21_decimal value_1, s21_decimal value_2, s21_decimal *result)</code></strong>
          <ul>
            <li>Обработка деления на ноль: Если <code>value_2</code> равно нулю, верните <code>DIVISION_BY_ZERO</code>.</li>
            <li>Определите знак результата.</li>
            <li>Выполните деление мантисс. Это сложный алгоритм, часто использующий длинное деление.</li>
            <li>Вычтите степени.</li>
            <li>Округлите результат в соответствии с правилами (например, банковское округление).</li>
            <li>Проверьте на переполнение/андерфлоу.</li>
          </ul>
        </li>
      </ul>

      <h4>4. Коды ошибок</h4>
      <p>Определите перечисление или константы для кодов ошибок:</p>
      <pre><code class="c">
enum {
    OK = 0,
    OVERFLOW = 1,
    NEGATIVE_OVERFLOW = 2,
    DIVISION_BY_ZERO = 3
};
      </code></pre>

      <h4>5. Тестирование</h4>
      <p>Напишите исчерпывающие модульные тесты для каждой функции, особенно для граничных случаев и сценариев переполнения/андерфлоу.</p>
    `
    }
};
