export const overflowContent = {
  'overflow_handling': {
    id: 'overflow_handling',
    title: 'Обработка переполнения',
    description: 'Как s21_decimal обрабатывает переполнение и потерю точности.',
    template: `
      <h3>Переполнение и потеря точности</h3>
      <p>Мантисса в <code>s21_decimal</code> ограничена 96 битами. Это значит, что она может хранить очень большие числа, но не бесконечные. Когда результат арифметической операции (например, сложения или умножения) превышает это ограничение, происходит <b>переполнение</b>.</p>
      <p>Библиотека должна обнаруживать такие ситуации перед выполнением операции, чтобы предотвратить неверные результаты и сообщить об ошибке.</p>
      <h4>Логика реализации: Мышление программиста</h4>
      <p>Как я могу заранее узнать, что сложение <code>a + b</code> приведет к переполнению, не выполняя само сложение? Я могу использовать простое свойство математики.</p>
      <p>Максимальное значение для 96-битного беззнакового числа — это <code>MAX_UINT96</code>. Если <code>a > MAX_UINT96 - b</code>, то <code>a + b</code> гарантированно будет больше, чем <code>MAX_UINT96</code>. Эта проверка позволяет мне обнаружить переполнение до того, как оно произойдет.</p>
      <pre><code class="c">
// Вспомогательная функция для проверки переполнения при сложении мантисс
int check_add_overflow(s21_decimal value_1, s21_decimal value_2) {
    // Проверяем переполнение для каждого 32-битного блока
    unsigned int max_uint32 = 0xFFFFFFFF;
    int carry = 0;
    for (int i = 0; i < 3; i++) {
        unsigned int v1 = value_1.bits[i];
        unsigned int v2 = value_2.bits[i];
        // Если v1 > MAX - v2, то v1 + v2 > MAX
        if (v1 > max_uint32 - v2 - carry) {
            return 1; // Переполнение
        }
        // Упрощенный расчет переноса для следующего разряда
        carry = (v1 + v2 + carry) < v1;
    }
    return 0; // OK
}
      </code></pre>
      <h4>Визуализация переполнения</h4>
      <p>Интерактивный симулятор ниже демонстрирует этот процесс. Он показывает, как мантиссы двух чисел складываются и как их сумма соотносится с максимальным 96-битным значением.</p>
    `,
    interactive: 'overflow_simulator', // Changed from overflow_visualizer
  },
};
