export const otherContent = {
  'other_functions': {
    id: 'other_functions',
    title: 'Прочие функции',
    simple: 'Это дополнительные функции, которые помогают работать с `s21_decimal`, например, убрать дробную часть, поменять знак или округлить число.',
    why: 'Эти функции упрощают частые операции с десятичными числами, которые не являются основными арифметическими, но очень полезны в реальных задачах. Они помогают подготовить число к дальнейшим расчетам или отображению.',
    description: 'В этом разделе представлены дополнительные утилитарные функции для работы с `s21_decimal`, которые не относятся к основным арифметическим операциям, сравнению или преобразованию, но предоставляют важные возможности для манипуляции числами.',
    template: `
      <h3>Различные вспомогательные функции</h3>
      <p>Помимо основных арифметических операций, сравнений и преобразований, библиотека <code>s21_decimal</code> включает ряд других полезных функций, которые упрощают манипуляции с десятичными числами.</p>
      <h4>Пример использования s21_truncate:</h4>
      <pre><code class="c">
#include "s21_decimal.h"
#include <stdio.h>

int main() {
    s21_decimal val, truncated_val;
    s21_from_float_to_decimal(-123.456f, &val);

    // Отбрасываем дробную часть
    s21_truncate(val, &truncated_val);

    float float_result;
    s21_from_decimal_to_float(truncated_val, &float_result);
    printf("Результат: %f\n", float_result); // Вывод: -123.000000

    return 0;
}
      </code></pre>
      <h4>Логика реализации <code>s21_truncate</code>: Мышление программиста</h4>
      <ol>
        <li><b>Цель:</b> Мне нужно отбросить все, что стоит после запятой. Например, 123.456 должно стать 123.</li>
        <li><b>Как это связано со структурой?</b> Дробная часть определяется масштабом (scale). Если scale равен 2, это значит, что два знака находятся после запятой. Чтобы их убрать, мне нужно сделать scale равным 0.</li>
        <li><b>Процесс.</b> Я получаю текущий scale. Затем в цикле я делю мантиссу на 10 и уменьшаю scale на 1, пока scale не станет равен 0.</li>
        <li><b>Пример:</b> Число 123.45. Мантисса = 12345, scale = 2. <br/>- Делим 12345 на 10, получаем 1234. Scale становится 1. <br/>- Делим 1234 на 10, получаем 123. Scale становится 0. <br/>Готово. Новая мантисса — 123, новый scale — 0.</li>
        <li><b>Копирование.</b> Я не должен изменять исходное число, поэтому все операции я провожу над копией, а затем записываю результат в выходной параметр.</li>
      </ol>
      <h4>Логика реализации <code>s21_floor</code>: Мышление программиста</h4>
      <ol>
        <li><b>Цель:</b> Округлить число до ближайшего меньшего целого.</li>
        <li><b>Положительные числа.</b> Для положительных чисел (например, 123.45), это то же самое, что и <code>s21_truncate</code>. Результат — 123. Я могу просто вызвать truncate.</li>
        <li><b>Отрицательные числа.</b> Здесь сложнее. <code>floor(-123.45)</code> должен дать -124. А <code>truncate</code> даст -123.</li>
        <li><b>Алгоритм для отрицательных.</b> Сначала я усекаю число с помощью <code>truncate</code>. Затем я проверяю, было ли исходное число отрицательным и имело ли оно дробную часть. Если оба условия верны, я должен вычесть 1 из усеченного результата.</li>
      </ol>
      <p>Интерактивный симулятор ниже наглядно демонстрирует логику работы этих функций.</p>
    `,
    interactive: 'other_functions_simulator',
  },
};
