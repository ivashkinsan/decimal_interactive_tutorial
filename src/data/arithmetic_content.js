
export const arithmeticContent = {
    'arithmetic_operations': {
        title: 'Арифметические операции',
        interactive: 'arithmetic_simulator',
        simple: 'Это базовые математические действия: сложение, вычитание, умножение и деление. Симулятор позволяет выполнять их с `s21_decimal` и видеть, как это происходит "под капотом".',
        why: 'Без точной и надежной арифметики невозможно проводить никакие расчеты, особенно в финансовой сфере. Эти функции — ядро всей библиотеки.',
        description: 'Каждая арифметическая операция работает с 96-битными мантиссами и управляющими битами (`scale` и знак) в `bits[3]`. Перед сложением и вычитанием числа приводятся к общему `scale` (нормализуются). При умножении их `scale` складываются, а при делении — вычитаются.'
    },
    's21-decimal-c-plan': {
        id: 's21-decimal-c-plan',
        title: 'План реализации на C',
        description: 'Подробный план по написанию функций s21_decimal на языке C.',
        template: `
      <h3>Общий план реализации функций s21_decimal на C</h3>
      <p>Для успешной реализации библиотеки s21_decimal на языке C необходимо следовать четкому плану, учитывая особенности представления десятичных чисел и требования к точности.</p>

      <h4>1. Структура s21_decimal</h4>
      <p>Определите структуру <code>s21_decimal</code>, которая будет хранить 128-битное десятичное число. Обычно это достигается использованием массива из четырех 32-битных целых чисел (<code>int bits[4]</code>).</p>
      <ul>
        <li><code>bits[0]</code>, <code>bits[1]</code>, <code>bits[2]</code>: Хранят 96-битную мантиссу числа. <code>bits[0]</code> - младшие биты, <code>bits[2]</code> - старшие.</li>
        <li><code>bits[3]</code>: Хранит информацию о знаке и степени (масштабе).
          <ul>
            <li>Биты 0-15: Не используются (зарезервированы).</li>
            <li>Биты 16-23: Хранят степень (scale) от 0 до 28.</li>
            <li>Биты 24-30: Не используются (зарезервированы).</li>
            <li>Бит 31: Хранит знак числа (0 для положительного, 1 для отрицательного).</li>
          </ul>
        </li>
      </ul>
      <pre><code class="c">
typedef struct s21_decimal {
    int bits[4];
} s21_decimal;
      </code></pre>

      <h4>2. Вспомогательные функции</h4>
      <p>Реализуйте набор вспомогательных функций для работы с битами, знаком и степенью:</p>
      <ul>
        <li><code>s21_get_sign(s21_decimal dec)</code>: Возвращает знак числа.</li>
        <li><code>s21_set_sign(s21_decimal *dec, int sign)</code>: Устанавливает знак числа.</li>
        <li><code>s21_get_scale(s21_decimal dec)</code>: Возвращает степень числа.</li>
        <li><code>s21_set_scale(s21_decimal *dec, int scale)</code>: Устанавливает степень числа.</li>
        <li><code>s21_is_zero(s21_decimal dec)</code>: Проверяет, равно ли число нулю.</li>
        <li><code>s21_shift_left(s21_decimal *dec, int shift)</code>: Сдвигает мантиссу влево.</li>
        <li><code>s21_shift_right(s21_decimal *dec, int shift)</code>: Сдвигает мантиссу вправо.</li>
        <li><code>s21_normalize(s21_decimal *value_1, s21_decimal *value_2)</code>: Приводит два числа к общей степени, увеличивая степень меньшего числа и умножая его мантиссу.</li>
        <li><code>s21_add_mantissa(s21_decimal value_1, s21_decimal value_2, s21_decimal *result)</code>: Складывает только мантиссы двух чисел (без учета знака и степени). Возвращает код ошибки переполнения.</li>
        <li><code>s21_sub_mantissa(s21_decimal value_1, s21_decimal value_2, s21_decimal *result)</code>: Вычитает только мантиссы двух чисел.</li>
      </ul>

      <h4>3. Арифметические операции</h4>
      <p>Основные арифметические функции должны учитывать знаки, приводить числа к общей степени и обрабатывать переполнение.</p>
      <ul>
        <li><strong><code>int s21_add(s21_decimal value_1, s21_decimal value_2, s21_decimal *result)</code></strong>
          <ul>
            <li>Обработка знаков: Если знаки разные, операция превращается в вычитание.</li>
            <li>Нормализация: Приведите <code>value_1</code> и <code>value_2</code> к общей степени с помощью <code>s21_normalize</code>.</li>
            <li>Сложение мантисс: Используйте <code>s21_add_mantissa</code>.</li>
            <li>Обработка переполнения: Если <code>s21_add_mantissa</code> возвращает ошибку переполнения, установите соответствующий код ошибки (например, <code>OVERFLOW</code> или <code>NEGATIVE_OVERFLOW</code>).</li>
            <li>Установка знака и степени результата.</li>
          </ul>
        </li>
        <li><strong><code>int s21_sub(s21_decimal value_1, s21_decimal value_2, s21_decimal *result)</code></strong>
          <ul>
            <li>Аналогично сложению, но с учетом правил вычитания для разных знаков.</li>
            <li>Используйте <code>s21_sub_mantissa</code>.</li>
          </ul>
        </li>
        <li><strong><code>int s21_mul(s21_decimal value_1, s21_decimal value_2, s21_decimal *result)</code></strong>
          <ul>
            <li>Определите знак результата.</li>
            <li>Умножьте мантиссы. Это может потребовать итеративного сложения или более сложного алгоритма для 96-битных чисел.</li>
            <li>Сложите степени.</li>
            <li>Проверьте на переполнение мантиссы и степени.</li>
          </ul>
        </li>
        <li><strong><code>int s21_div(s21_decimal value_1, s21_decimal value_2, s21_decimal *result)</code></strong>
          <ul>
            <li>Обработка деления на ноль: Если <code>value_2</code> равно нулю, верните <code>DIVISION_BY_ZERO</code>.</li>
            <li>Определите знак результата.</li>
            <li>Выполните деление мантисс. Это сложный алгоритм, часто использующий длинное деление.</li>
            <li>Вычтите степени.</li>
            <li>Округлите результат в соответствии с правилами (например, банковское округление).</li>
            <li>Проверьте на переполнение/андерфлоу.</li>
          </ul>
        </li>
      </ul>

      <h4>4. Коды ошибок</h4>
      <p>Определите перечисление или константы для кодов ошибок:</p>
      <pre><code class="c">
enum {
    OK = 0,
    OVERFLOW = 1,
    NEGATIVE_OVERFLOW = 2,
    DIVISION_BY_ZERO = 3
};
      </code></pre>

      <h4>5. Тестирование</h4>
      <p>Напишите исчерпывающие модульные тесты для каждой функции, особенно для граничных случаев и сценариев переполнения/андерфлоу.</p>
    `
    }
};
