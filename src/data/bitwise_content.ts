export const bitwiseContent = {
  'bitwise_operations': {
    id: 'bitwise_operations',
    title: 'Побитовые операции',
    simple: 'Побитовые операции позволяют работать с числами на самом низком уровне — с их битами (нулями и единицами). Это как если бы вы разбирали число на мельчайшие детали и меняли их.',
    why: 'Побитовые операции используются для очень быстрых вычислений, маскирования (выделения или скрытия определенных битов), установки или сброса флагов. В `s21_decimal` они применяются к мантиссе для низкоуровневых манипуляций, которые могут быть частью более сложных арифметических функций.',
    description: 'В этом разделе рассматриваются побитовые операции (AND, OR, XOR, NOT), применимые к мантиссе чисел типа `s21_decimal`. Объясняется, как эти операции выполняются на 96-битной мантиссе, представленной тремя 32-битными целыми числами.',
    template: `
      <h3>Побитовые операции с s21_decimal</h3>
      <p>Побитовые операции (AND, OR, XOR, NOT) могут быть применены к мантиссе <code>s21_decimal</code> для низкоуровневых манипуляций битами. Поскольку мантисса <code>s21_decimal</code> состоит из трех 32-битных целых чисел (<code>bits[0]</code>, <code>bits[1]</code>, <code>bits[2]</code>), побитовые операции выполняются отдельно для каждого из этих 32-битных "кусков".</p>
      <h4>Пример использования s21_bitwise_and:</h4>
      <pre><code class="c">
#include "s21_decimal.h"

int main() {
    s21_decimal val1, val2, result;
    s21_from_int_to_decimal(10, &val1); // 1010 в двоичной
    s21_from_int_to_decimal(12, &val2); // 1100 в двоичной

    // 1010 & 1100 = 1000 (что равно 8)
    s21_bitwise_and(val1, val2, &result);

    int int_result;
    s21_from_decimal_to_int(result, &int_result);
    // int_result будет равен 8

    return 0;
}
      </code></pre>
      <h4>Логика реализации <code>s21_bitwise_and</code>: Мышление программиста</h4>
      <ol>
        <li><b>Цель:</b> Выполнить побитовое "И" для двух 96-битных мантисс.</li>
        <li><b>Структура данных:</b> Мантисса хранится в трех <code>int</code> (<code>bits[0]</code>, <code>bits[1]</code>, <code>bits[2]</code>). Это значит, что я не могу применить оператор <code>&</code> ко всей 96-битной мантиссе сразу.</li>
        <li><b>Пошаговое применение:</b> Я должен применить операцию <code>&</code> к каждой паре соответствующих 32-битных частей. То есть, я вычислю <code>result.bits[0] = value_1.bits[0] & value_2.bits[0]</code>, затем то же самое для <code>bits[1]</code> и <code>bits[2]</code>.</li>
        <li><b>Что делать с <code>bits[3]</code>?</b> Побитовые операции обычно не затрагивают знак и масштаб. Логичным решением будет просто скопировать <code>bits[3]</code> из первого операнда (<code>value_1</code>) в результат.</li>
        <li><b>Ошибки.</b> В отличие от арифметических операций, здесь не может быть переполнения. Поэтому функция может ничего не возвращать (<code>void</code>) или возвращать 0 (OK) для единообразия.</li>
      </ol>
      <p>Интерактивный симулятор ниже позволит вам экспериментировать с различными числами и побитовыми операциями.</p>
    `,
    interactive: 'bitwise_operations_simulator',
  },
};
